---
seoMetaData:
  title: "What I'm learning in 2024"
  description: "What I'm learning in 2024"
  ogImage: ''
  ogImageAlt: ''
title: "What I'm learning in 2024"
publishedDate: 2024-01-24
---

Engineering is an ever-expanding ecosystem.

Learning different frameworks, libraries, tools, and technologies is not just akin to accumulating points for a showoff (although that's cool, considering how many possibilities exist today), but rather a journey to gain valuable insights, becoming a better engineer, and continuously learning the principles of shipping better product.

For me at the end, it's about choosing the right tools to craft and deliver superior, fast, and resilient products for my users, which often times than not means leveraging the ecosystem, upskilling on the ecosystem and staying upto date with the ecoystem.

So here's my ambitious plan to what I'm learning in 2024:

{/* ========== Frameworks =============== */}

<section>

## UI Frameworks

I think it's the inevitable one for me. As a Frontend Engineer, leveraging the framework and it's features is my most prominent responsibility, after all I need to architect a better product.

### Astro

In the war of frameworks, [Astro](https://astro.build/ 'Astro: The web framework for content-driven websites') has won big time for me!.

The simplicty of writing just plain old HTML while still leveraging the expressiveness and ease of composing user interfaces using my preferred libray [React](https://react.dev/ 'React: Javascript library for building user interfaces') is just special.

It's fast, easy and the [architecture](https://docs.astro.build/en/concepts/islands/ 'Astro: Islands Architecture') just makes sense when you think about it.

Not having to worry about the lack of useful development packages is just another cherry on top for me. I can leverage React's ecosystem whenever I need to, and work with plain old HTML otherwise.

Also, let me be honest, creating and importing a direct [HTML Component](https://docs.astro.build/en/core-concepts/astro-components/#html-components 'HTML Components in Astro') just hits different. No VDOM, no love child like JSX, just plain old HTML ðŸ’˜.

**Fun fact**: The [site](https://github.com/abhu-A-J/abhushan.dev 'Github: Abhushan Adhikari Joshi website') you're currently on is also built using Astro.

### Remix

As someone who enjoys learning new things on web, one fact still prevails for me today: finding myself consistently returning to the fundamentals, reconnecting with [Web Standards](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards 'MDN: Web and Web Standards').

Whether it's for interview preparation, reacquainting myself with forgotten topics, or exploring newly introduced Web API's. The foundations of web is crucial and inevitable.

[Remix](https://remix.run/ 'Remix: Focused on web standards and modern web app UX, youâ€™re simply going to build better websites'), as a fullstack web framework, stands out in its remarkable utilization of these standards. It seamlessly integrates a bundler, HTTP handler, server and client framework, making it versatile to build and be deployed anywhere, thanks to its adherence to web standards.

Take forms for start, who knew [forms](https://remix.guide/resources/RHXuuyvI9uIz?platform=render&sort=top 'Youtube: Why The Form by Ryan Florence') could do so much ðŸ¥¹ ?.

Having worked with [Next.js](https://nextjs.org/ 'Next.js: The React Framework for the Web') already, I think learning how to leverage Remix and understand it's differences with Next.js and it's leading React Server Components first paradigm, will help me make better decisions for building application at the end of the day.

And to learn Remix, you need to learn the web standards first, which only means getting better as a web developer in long run.

</section>

{/* ========== Blockchain =============== */}

<section>

## Blockchain

As much as I enjoy working on the Web, expanding horizons and experimenting with newer technologies has always been my guilty pleasure.

Be it networking, databases or devops, the goal never is to master the technology, but to get a broader view of building applications end to end.

Learning beyond my primary field, often helps me bring in new ideas, ways to approach solving a problem, or in general help build product with better planning and responsibiity.

I look forward to learing the following this year:

### Solidity

To make a full stack DApp, you need a smart contract for writing and getting information from the blockhain. [Solidity](https://en.wikipedia.org/wiki/Solidity 'Wikipeda: Solidity') is the language required to build smart contract on EVM chains.

Honestly, having worked with Javascript and Typescript for so long, I do defnitely look forward to learning a "actual" statically typed lanaguage to say the least. ðŸ˜…

### DApps

Blockchain as a technology is quite fascinating to say the least. With an extremely ambitious goal of transforming the web forever ([Web 3.0](https://en.wikipedia.org/wiki/Web3 'Wikipedia: Web 3.0 the future of web')), it surely has been the most talked about topic in past few years.

But as a Frontend Developer, I'm mostly interested not the core technology itself, but building full stack applications which leverages blockchain (often called [DApps](https://en.wikipedia.org/wiki/Decentralized_application 'Wikipedia: Decentralized applications')) based the distributed architecture of [EVM](https://en.wikipedia.org/wiki/Ethereum 'Wikipedia: Ethereum Blockchain') chains.

The idea of being able to communicate with a [smart contract](https://en.wikipedia.org/wiki/Smart_contract 'Wikipedia: Smart Contract') deployed on a peer to peer network and building really resilient user experiences on top of that despite it's challenges is definitely a challenge worth exploring in my books.

With my current Web 2.0 skills, I think it's only fitting to understand how all pieces in Web3.0 comes together.

</section>

{/* ========== Testing =============== */}

<section>

## Testing

No matter which field or company or product I work in, making sure my code is reliable and bug free is something which is important to me and I can't ignore.

Although, I always leverage static analysis tools like [Eslint](https://eslint.org/ 'Eslint: Find and fix problems in your JavaScript code'), [Typescript](https://www.typescriptlang.org/ 'Typescript: JavaScript with types') to catch bugs early on during development, which debatably makes a ton of unit and integration test unnecessary, but having an safe-guard to your code through robust testing never hurts.

To level up as a Senior Engineer, it's essential that the code I am producing is accounted and tested for giving me the confidence to ship faster and better.

Unit testing with keeping fundamentals in mind like [monkey-patching](https://en.wikipedia.org/wiki/Monkey_patch. 'Wikipedia: Monkey Patching'), [mocking](https://stackoverflow.com/questions/2665812/what-is-mocking 'Mocking: Unit Testing') and [stubbing](https://en.wikipedia.org/wiki/Test_stub 'Wikipedia: Stubs in Testing') can be quite essential to writing lean and composable units.

Having most of my experience at only early stage startup, testing never got the primary attention from me and team, so I plan on filling my knowledge gap on unit and integration testing by focussing on two tools in general:

### Vitest

With more and more packages, now suporting ESM modules, it's pretty clear that ESM modules is definitely the future for web and [Vitest](https://vitest.dev/ 'Vitest: Next Generation Testing Framework') being ESM first, it's a perfect framework to learn for testing your application code.

Don't get me wrong, [Jest](https://jestjs.io/ 'Jest: JavaScript Testing Framework') is great tool as well and has served a great set of resources until now. But Vitest's native integration to Vite and it's plugins ecosystem, makes it extremely powerful, fast and is feature rich out of the box with almost zero configurations.

Moreover, it's API being Jest compatable means learning skills are very much transferrable across both tools ðŸ˜„.

### Testing Library

As a Frontend Enginner, testing UI components is not going away from me. Testing Library is the friend you need when it comes to testing components in user-centric ways.

The more tests I can write which resemble the way my software is used, the more confidence I can have in shipping them.

So, I'm learning about [DOM Testing Library](https://testing-library.com/docs/dom-testing-library/intro 'DOM Testing Libray') and [React Testing Library](https://testing-library.com/docs/react-testing-library/intro 'React Testing Library') and upskill myself to be a better engineer.

</section>

{/* ========== Miscellaneous =============== */}

<section>

## Conclusion

I wholeheartedly endorse the concept of learning through hands-on projects. This approach has been instrumental in my personal development, as the accumulation of various small, diverse projects has significantly enhanced my skills.

The process of building from scratch, tackling random challenges, and ultimately completing comprehensive end-to-end projects has been a key factor in my continuous improvement and upskilling journey.

This year is going to be no different, I look forward to using the above mentioned technologies and building something I can see myself use in my other works.

</section>
