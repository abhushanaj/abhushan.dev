---
seoMetaData:
  title: 'Array.prototype.map polyfill'
  description: 'Implement a polyfill for Array.prototype.map method for JavaScript/Frontend interviews.'
  ogImage: '/open-graph/blogs/implement-a-map-polyfill.webp'
  ogImageAlt: 'Implement a polyfill for Array.prototype.map method'
title: 'Array.prototype.map polyfill'
publishedDate: 2024-04-05
inProgress: false
blogMeta:
  type: 'series-part'
  seriesParentSlug: 'polyfill-questions-for-frontend-interviews'
---

<section>
## 1. Basic implementation

```js title="./src/map.js"
Array.prototype.myMap = function (predicate) {
	// "this" is the arr on which map method is called (left side of .(dot))
	const arr = this;

	const result = [];

	if (!arr.length) {
		return result;
	}

	for (let i = 0; i < arr.length; i++) {
		const item = arr[i];
		// check if the item is not empty (for sparse arrays)
		if (i in arr) {
			const predicateValue = predicate(item, i, arr);
			result.push(predicateValue);
		} else {
			result.push(item);
		}
	}

	return result;
};

// Usage
function callback(item, index, arr) {
	return item * 2;
}
const inputArr = [1, 2, 3, , 5];

const originalMap = inputArr.map(callback);
const customMap = inputArr.myMap(callback);

console.log(originalMap); // yields [2,4,6,empty,10]
console.log(customMap); // yields [2,4,6,empty,10]

console.log(JSON.stringify(originalMap) === JSON.stringify(customMap)); // yields true
```

</section>

{/* ============= Variation: with thisArg  ========= */}

<section>
<SubHeading>Variation: thisArg argument</SubHeading>
## 2. With thisArg  implementation

There is also a second argument which we can pass to the map method which is the value of the "this" for the predicate function, when it is invoked.

The implemetation remains exactly same, so I am highlighting only the new additions.

```js title="./src/map.js" ins={15,27,31,32} mark="thisArg"
Array.prototype.myMap = function (predicate, thisArg) {
	// "this" is the arr on which map method is called (left side of .(dot))
	const arr = this;

	const result = [];

	if (!arr.length) {
		return result;
	}

	for (let i = 0; i < arr.length; i++) {
		const item = arr[i];
		// check if the item is not empty (for sparse arrays)
		if (i in arr) {
			const predicateValue = predicate.call(thisArg, item, i, arr);
			result.push(predicateValue);
		} else {
			result.push(item);
		}
	}

	return result;
};

// Usage
function callback(item, index, arr) {
	return item * 2 + this.offset;
}
const inputArr = [1, 2, 3, , 5];

const originalMap = inputArr.map(callback, { offset: 2 });
const customMap = inputArr.myMap(callback, { offset: 2 });

console.log(originalMap); // yields [4,6,8,empty,12]
console.log(customMap); // yields [4,6,8,empty,12]

console.log(JSON.stringify(originalMap) === JSON.stringify(customMap)); // yields true
```

</section>

<br />

In both above implementationsW I have not patched the original map method on purpose so I can showcase the comparision of results
from original and our implementation. In the interview setting feel free to mention that to the interviewer.

```js title="./src/map.js"
if (!Array.prototype.map) {
	Array.prototype.map = function () {
		// the implemetation provided above
	};
}
```

## Further Reading

I strongly encourage you to explore and tackle additional questions in my [Polyfill Questions for Frontend Interviews](/blog/polyfill-questions-for-frontend-interviews/ 'Find more question on polyfills for JavaScript/Frontend interviews blog series') blog series.

By doing so, you can enhance your understanding and proficiency with recursion, preparing you to excel in your upcoming frontend interviews.

**_Wishing you best. Happy Interviewing_** ðŸ«¡.
